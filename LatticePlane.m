(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["LatticePlane`","NDSolve`FEM`","OpenCascadeLink`"(*,"CifImport`"*),"MaXrd`"];
Unprotect@@Names[Evaluate[Context[]<>"*"]];
Unprotect[Evaluate[Context[]<>"*"]];
ClearAll@@Names[Evaluate[Context[]<>"*"]];
ClearAll[Evaluate[Context[]<>"Private`*"]];


(* ::Input::Initialization:: *)
ParseHKL::usage="ParseHKL[hklIn]";
Reciprocal::usage="Reciprocal[hklIn";
AssignAxis::usage="AssignAxis[n,valIn,\[Gamma]]";
AssignAxes::usage="AssignAxes[\[ScriptCapitalI],\[Gamma]]";
GetPositions::usage="GetPositions[\[ScriptCapitalI]]";
OneDimension::usage="OneDimension[\[ScriptCapitalI],\[Gamma]]";
TwoDimension::usage="TwoDimension[\[ScriptCapitalI],\[Gamma]]";
MillerToPlane::usage="MillerToPlane[hkl,\[Gamma]]";
UnitCell::usage="UnitCell[xyz]";
InterplanarAngle::usage="InterplanarAngle[hkl1,hkl2,lattice]";
DegenerateMesh::usage="DegenerateMesh[v]";
TotalIntersectionArea::usage="TotalIntersectionArea[\[ScriptCapitalT],\[ScriptCapitalB]]";
PlaneIntersection::usage="PlaneIntersection[\[ScriptCapitalP],\[ScriptCapitalU]]";
RationalUnitCell::usage="RationalUnitCell[p]";
QUC::usage="QUC[x]";
ImportCrystalData2::usage="ImportCrystalData2[ciffile,name]";
ExpandCrystal2::usage="ExpandCrystal2[crystalData,{n,n,n}]";
AtomPolygonBallsIntersection::usage="AtomPolygonBallsIntersection[P,c,r]";
PolygonBallsIntersection::usage="PolygonBallsIntersection[P,c,r]";
AtomProbabilityIntersection::usage="AtomProbabilityIntersection[\[ScriptCapitalD],P]";
ProbabilityIntersection::usage="ProbabilityIntersection[\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP]]";
SetupDensityHKL::usage="SetupDensityHKL[mpid,n,hklMax,radiusFactor]";
GetFullHKL::usage="GetFullHKL[valsIn,hklIn,pg]";
DensityHKL::usage=
"{\!\(\*SubscriptBox[\(\[ScriptCapitalA]\), \(int, n\)]\),\!\(\*SubscriptBox[\(hkl\), \(list\)]\),\!\(\*SubscriptBox[\(\[ScriptCapitalE]\), \(unique\)]\)}=DensityHKL[mpid,n,hklMax,radiusFactorIn];
{\!\(\*SubscriptBox[\(\[ScriptCapitalA]\), \(int, n\)]\),\!\(\*SubscriptBox[\(hkl\), \(list\)]\),\!\(\*SubscriptBox[\(\[ScriptCapitalE]\), \(unique\)]\)}=DensityHKL[mpid,n,hklMax,radiusFactorIn,\"Method\"\[Rule]\"PDF\"];"
PlotSetup::usage="{\!\(\*SubscriptBox[\(hkl\), \(list\)]\),reflectionList,pg}=PlotSetup[mpid,n,hklMax];"
PlotSymmetrizedHKL::usage="g=PlotSymmetrizedHKL[vals,hkl,o,legendLabel];"
PlotFullHKL::usage="g=PlotFullHKL[valsIn,hklIn,pg,o,legendLabel];"
PlotSymmetrizedFullHKL::usage="g=PlotSymmetrizedFullHKL[\!\(\*SubscriptBox[\(\[ScriptCapitalA]\), \(out, n\)]\),\!\(\*SubscriptBox[\(hkl\), \(list\)]\),pg,\!\(\*SubscriptBox[\(\[ScriptCapitalE]\), \(unique\)]\),tag];"


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ParseHKL[hklIn_]:=Module[{hkl},
hkl=hklIn/.{OverBar->Minus,0->Indeterminate};
If[Length@hkl==4,hkl=hkl[[{1,2,4}]],hkl]
]


(* ::Input::Initialization:: *)
Reciprocal[hklIn_]:=1/ParseHKL@hklIn


(* ::Input::Initialization:: *)
MillerToPlane[hkl_,Rin_]:=Module[{\[ScriptCapitalI],R,negQ,\[ScriptCapitalO],pos,zeroPosition,finitePosition,axisIntersection},
\[ScriptCapitalI]=Reciprocal[hkl];
R=Rationalize[Rin,0];(*basis vectors*)
\[ScriptCapitalO]={0,0,0};(*reference point*)
negQ=Negative[\[ScriptCapitalI]/.Indeterminate->0];(*which ones are negative?*)
MapThread[If[#1,\[ScriptCapitalO]=\[ScriptCapitalO]+#2]&,{negQ,R}];(*if negative, shift the reference point in the positive direction along an axis*)
zeroPosition=Flatten@Position[hkl,0];(*which hkl values are 0?*)
finitePosition=Complement[Range@3,zeroPosition];(*which hkl values are finite?*)
axisIntersection=\[ScriptCapitalO]+#&/@(\[ScriptCapitalI][[finitePosition]]R[[finitePosition]]); (*using the finite hkl values, compute axis intersections*)
R=MapThread[If[#1,-#2,#2]&,{negQ,R}];(*if negative, flip the basis vector*)
If[Length@zeroPosition>0,
AppendTo[axisIntersection,axisIntersection[[1]]-R[[#]]]&/@zeroPosition]; (*get point(s) in plane (if any) for remaining hkl indices that are 0*)
InfinitePlane[axisIntersection]
]


(* ::Input::Initialization:: *)
ReadXYZ[xyzpath_]:=Import[xyzpath,"Table"][[3;;,2;;4]];


(* ::Input::Initialization:: *)
UnitCell[xyz_]:=Module[{\[ScriptCapitalM],\[ScriptP],\[ScriptCapitalC],P,i,\[ScriptCapitalN],\[ScriptCapitalO]},
\[ScriptCapitalM]=Region`Mesh`MergeCells@ConvexHullMesh@Rationalize[xyz,0];
\[ScriptP]=MeshCoordinates@\[ScriptCapitalM];
(*\[ScriptP]=\[ScriptP](1+$MachineEpsilon);*)
\[ScriptCapitalC]=MeshCells[\[ScriptCapitalM],1][[;;,1]];
(*\[ScriptM]={\[ScriptCapitalC]\[LeftDoubleBracket]#\[RightDoubleBracket],\[ScriptP]\[LeftDoubleBracket]#\[RightDoubleBracket]}&/@Range@Length@\[ScriptP];
\[ScriptCapitalN]=Select[\[ScriptM],ContainsAny[#\[LeftDoubleBracket]1\[RightDoubleBracket],{1}]&]\[LeftDoubleBracket];;,2\[RightDoubleBracket];*)
P=Position[\[ScriptCapitalC],_?(ContainsAny[#,{1}]&),1]//Flatten;
i=DeleteCases[Flatten[\[ScriptCapitalC][[P]]],1];
\[ScriptCapitalN]=\[ScriptP][[i]];
\[ScriptCapitalO]=\[ScriptP][[1]];(*\[ScriptCapitalN]=Nearest[\[ScriptP]\[LeftDoubleBracket]2;;\[RightDoubleBracket],\[ScriptCapitalO],3];*)
Parallelepiped[\[ScriptCapitalO],\[ScriptCapitalN]]
]


(* ::Input::Initialization:: *)
RationalUnitCell[R_,n_:1]:=Module[{R1,R2,R3,c,\[ScriptCapitalU]pts,\[ScriptCapitalU]},
{R1,R2,R3}=R(1+100$MachineEpsilon);(*for some reason Kernel aborts unexpectedly without the machine precision factor*)
c=Floor[n/2](R1+R2+R3);(*corner*)
\[ScriptCapitalU]pts=#-c&/@(n{{0,0,0},R1,R2,R3,R1+R2,R2+R3,R1+R3,R1+R2+R3});
\[ScriptCapitalU]=ConvexHullMesh@\[ScriptCapitalU]pts;
Polyhedron[Rationalize[MeshCoordinates@\[ScriptCapitalU],0],MeshCells[\[ScriptCapitalU],2][[;;,1]]] 
]


(* ::Input::Initialization:: *)
InterplanarAngle[hkl1_,hkl2_,lattice_:"cubic"]:=Module[{h1,k1,l1,h2,k2,l2},
{h1,k1,l1}=ParseHKL@hkl1/. Indeterminate\[RightArrow]0;
{h2,k2,l2}=ParseHKL@hkl2/. Indeterminate\[RightArrow]0;Switch[lattice,"cubic",ArcCos[ (h1 h2+k1 k2+l1 l2)/Sqrt[(h1^2+k1^2+l1^2)(h2^2+k2^2+l2^2)]],"hexagonal",Null,"tetragonal",Null,"trigonal",Null,"monoclinic",Null,"triclinic",Null,"orthorhombic",Null]]


(* ::Input::Initialization:: *)
DegenerateMesh[v_]:=Module[{\[ScriptCapitalR],\[ScriptCapitalN]},\[ScriptCapitalR]=DelaunayMesh@DimensionReduce@v;
\[ScriptCapitalN]=Range@Length@v;
\[ScriptCapitalT]=Last@MeshCells@\[ScriptCapitalR]/. Polygon\[RightArrow]Simplex/. MapThread[#1\[RightArrow]#2&,{\[ScriptCapitalN],v}]]


(* ::Input::Initialization:: *)
TotalIntersectionArea[\[ScriptCapitalT]_,\[ScriptCapitalB]_]:=Table[Area@RegionIntersection[t,b],{t,\[ScriptCapitalT]},{b,\[ScriptCapitalB]}]/. Undefined\[RightArrow]Sequence@@{}//Flatten//Total


(* ::Input::Initialization:: *)
PlaneIntersection[\[ScriptCapitalP]_,\[ScriptCapitalU]_]:=Module[{\[ScriptCapitalP]1,\[ScriptCapitalB],\[ScriptCapitalM],\[ScriptCapitalP]crop,\[ScriptCapitalP]int,shapes,bmesh,d,order,coords,TF},
If[Head@\[ScriptCapitalP]===InfinitePlane,\[ScriptCapitalP]1={\[ScriptCapitalP]},\[ScriptCapitalP]1=\[ScriptCapitalP]];
\[ScriptCapitalB]=RegionResize[BoundingRegion[\[ScriptCapitalU]],Scaled@Rationalize[1.1(*100$MachineEpsilon*)]];(*for cropping the plane*)
\[ScriptCapitalP]crop=RegionIntersection[#,\[ScriptCapitalB]]&/@\[ScriptCapitalP]1;
\[ScriptCapitalP]int=RegionIntersection[#,N@\[ScriptCapitalU]]&/@N[\[ScriptCapitalP]crop];
shapes=OpenCascadeShape[#]&/@\[ScriptCapitalP]int;
bmesh=OpenCascadeShapeSurfaceMeshToBoundaryMesh[#]&/@shapes;
coords=#["Coordinates"]&/@bmesh;
TF=CoplanarPoints/@coords;
coords=MapThread[If[#1,#2,DimensionReduction[#2,2][#2,"ReconstructedData"]]&,{TF,coords}];
{d,order}=(FindShortestTour[#]&/@coords)\[Transpose];
\[ScriptCapitalP]int=MapThread[Polygon[#1[[#2[[;;-2]]]]]&,{coords,order}]
]


(* ::Input::Initialization:: *)
QUC[x_]:=QuantityMagnitude@UnitConvert@x


(* ::Input::Initialization:: *)
IsotropicMultinormal[pts_,r_]:=MapThread[MultinormalDistribution[#1,DiagonalMatrix@ConstantArray[#2,3]]&,{pts,r}]


(* ::Input::Initialization:: *)
ImportCrystalData2::subdataInteger="\"\!\(\*
StyleBox[\"ExtractSubdata\", \"Program\"]\)\" must be a positive integer.";
ImportCrystalData2::subdataLength="The \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"cif\", \"Program\"]\) file has a subdata length of `1`.";
ImportCrystalData2::latticeParameters="No lattice parameters were located, or they have an invalid form.";
ImportCrystalData2::atomData="No atom data was located.";
ImportCrystalData2::SG="Could not determine space group. 'P1' will be used.";
ImportCrystalData2::cell="Could not work out the unit cell properly.";
ImportCrystalData2::notMaXrd="Data collected using `1` radiation. Errors may occur.";
ImportCrystalData2::modulation="Modulated structure detected. Errors may occur.";
ImportCrystalData2::SpecialLabel="\[LeftGuillemet]`1`\[RightGuillemet] is a reserved label and should not be used.";

Options@ImportCrystalData2={
"DataFile"->"CrystalData2.m",
"ExtractSubdata"->1,
"IgnoreIonCharge"->False,
"Notes"-><||>,
"RoundAnglesThreshold"->0.001,
"Units"->True,
"OverwriteWarning"->True
};

SyntaxInformation@ImportCrystalData2={
"ArgumentsPattern"->{___,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
ImportCrystalData2[
{CrystalName_String,
ChemicalFormula:_?StringQ:"",
Z:_?IntegerQ:0,
SpaceGroup_:1,
Wavelength:_?NumericQ:-1
},
GetLatticeParameters_List,
AtomData_List,
OptionsPattern[]
]:=Block[
{choice,name,sg,cell,\[Delta],fr,latticeItem,\[Lambda],itemAtomData,item,dataFile=OptionValue["DataFile"],temp},

(*---* Check if name already exists *---*)
If[CrystalName==="",
name="ImportedCrystal_"<>DateString["ISODate"],name=CrystalName];
(*If[TrueQ@OptionValue["OverwriteWarning"],
	If[KeyExistsQ[$CrystalData,name],
	choice=ChoiceDialog["\[LeftGuillemet]"<>name<>
"\[RightGuillemet] already exists in $CrystalData.\nDo you want to overwrite this entry?"]];
	If[!choice,Return[]]
];*)

(*--- Space Group *---*)
sg=InputCheck["GetPointSpaceGroupCrystal",SpaceGroup];
sg=ToStandardSetting@sg;

(*---* Lattice parameters *---*)
If[!AllTrue[GetLatticeParameters,NumericQ[#]&]||
Length@GetLatticeParameters!=6,
Message[ImportCrystalData::latticeParameters]];

	(* Optional: Round angles *)
	cell=GetLatticeParameters;
	\[Delta]=OptionValue["RoundAnglesThreshold"];
	Do[
	fr=FractionalPart@cell[[i]];
	If[fr>0.5,fr=1-fr];
	If[fr<=\[Delta],cell[[i]]=Round@cell[[i]]],
	{i,4,6}];

	(* Optional: Use units *)
	If[OptionValue["Units"],
	Do[
	Which[
	i<=3,cell[[i]]=Quantity[cell[[i]],"Angstroms"],
	i>=4,cell[[i]]=Quantity[cell[[i]],"Degrees"]],
	{i,6}]];

	(* Prepare association entry *)
	latticeItem=Association@
	Thread[{"a","b","c","\[Alpha]","\[Beta]","\[Gamma]"}->cell];

(*---* Wavelength *---*)
	(* Optional: Use units *)
	If[OptionValue["Units"],
	\[Lambda]=Quantity[Wavelength,"Angstroms"],
	\[Lambda]=Wavelength];

(*---* Atom data *---*)
If[AtomData==={},
itemAtomData={<||>},

itemAtomData=Table[
DeleteMissing@Part[AtomData[[i]],{
"Element",
"OccupationFactor",
"SiteSymmetryMultiplicity",
"SiteSymmetryOrder",
"FractionalCoordinates",
"DisplacementParameters",
"Type"}],
{i,Length@AtomData}];

Do[
If[KeyExistsQ[First@itemAtomData,k],
itemAtomData=MapAt[
ToExpression,itemAtomData,{All,Key[k]}]],
	{k,{
	"OccupationFactor",
	"SiteSymmetryMultiplicity",
	"SiteSymmetryOrder",
	"DisplacementParameters"}}
];

	(* Checking strings in coordinates *)
	Do[itemAtomData[[i,"FractionalCoordinates"]]=itemAtomData[[i,"FractionalCoordinates"]]/.x_String:>ToExpression[x],
	{i,Length@itemAtomData}]
];

(*---* Preparing item *---*)
item=<|
	"ChemicalFormula"->ChemicalFormula,
	"FormulaUnits"->Z,
	"SpaceGroup"->sg,
	"LatticeParameters"->latticeItem,
	"Wavelength"->\[Lambda],
	"AtomData"->itemAtomData,
	"Notes"->OptionValue["Notes"]
	|>;

(* Delete certain keys *)
	If[item["ChemicalFormula"]==="",
	KeyDropFrom[item,"ChemicalFormula"]];

	If[item["Notes"]===<||>,
	KeyDropFrom[item,"Notes"]];

	If[!Positive@item["Wavelength"],
	KeyDropFrom[item,"Wavelength"]];

	If[Z===0,
	KeyDropFrom[item,"FormulaUnits"]];

	(* If all occupation factors = 1, delete column *)
	temp=item[["AtomData",All,"OccupationFactor"]];
	If[AllTrue[N@temp,#==1.&],
	item[["AtomData",All]]=KeyDrop[
	item[["AtomData",All]],"OccupationFactor"]];

	(* If all displacement parameters = 0, delete column *)
	temp=item[["AtomData",All,"DisplacementParameters"]];
	If[AllTrue[N@temp,#==0.&],
	item[["AtomData",All]]=KeyDrop[
	item[["AtomData",All]],
	{"DisplacementParameters","Type"}]];


(*InputCheck["Update$CrystalDataFile",dataFile,name,item];
InputCheck["ShallowDisplayCrystal",name]*)
item
]


(* ::Input::Initialization:: *)
ImportCrystalData2[ciffile_,Name_String:"",OptionsPattern[]]:=Block[{
(* A. Input check and setup *)name,specialLabels=Join[{"Void"},{"H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"}],import,sub,endstring,enc,left,mid,right,
modulationQ=False,
(* B. Lattice parameters *)cell,x,X,multipleQ,parts,coordCount,
(* C. Atom data *)atomdata,atomtags,c,
(* D. Anisotropic displacement parameters (ADPs) *)anisodata,anisoOrder,P,atomoverview,tags,labels,disp,item,
(* E. Misc data labels (wavelength, formula units) *)\[Lambda],Z,
(* F. Chemical formula *)formula,chemicalformula,L,l,r,checkParentheses,
(* G. Space group *)sgTags,sgData,sg,
(* H. Adding item to dataset *)options,
(* Misc *)temp},

(*---* A. Input check and setup *---*)
If[Name=="",name=FileBaseName[ciffile],name=Name];
If[MemberQ[specialLabels,name],
Message[ImportCrystalData2::SpecialLabel,name];Abort[]];

(* A.1. Check file *)
import=Check[Import[ciffile,"String"],Abort[]];
sub=OptionValue["ExtractSubdata"];
	If[!(IntegerQ[#]&&Positive[#]&@sub),
	Message[ImportCrystalData2::subdataInteger];
	Abort[]];

(* A.2. Auxiliary variables *)
endstring={"loop_","\n\n",";","#",EndOfString};
enc={"'","\""};(* annotation/enclosing marks *)
{left,mid,right}={"\!\(\*SubscriptBox[\(","\), \(","\)]\)"};

(* A.3. Check radiation type *)
temp=StringCases[import,
Shortest[{
"_diffrn_radiation_type","_diffrn_radiation_probe"}
~~Whitespace~~{"",enc}~~t:LetterCharacter..~~"\n"]:>t];
If[MemberQ[temp,#],Message[ImportCrystalData2::notMaXrd,#]]
&/@{"neutron","electron"};

(* A.4. Check for modulation *)
temp=If[StringContainsQ[import,"_space_group_ssg_name"],
modulationQ=True;
Message[ImportCrystalData2::modulation]];

(*---* B. Lattice parameters *---*)
(* B.1. Extracting lattice parameters *)
cell=StringCases[import,Shortest[
x:("_cell_"~~{"length","angle"}~~__~~
{DigitCharacter,"."}..)~~
{"(",Whitespace}]:>ToLowerCase@x,
IgnoreCase->True];

	(* Check *)
	If[cell=={},
	Message[ImportCrystalData2::latticeParameters];
	Abort[]];

(* B.2. Check for multiplue structures *)
	cell=StringSplit[cell,Whitespace];
	Which[
	Length@cell>6,
		multipleQ=True;parts=Length[cell]/6,
	Length@cell==6,
		multipleQ=False;parts=1,
	True,
		Message[ImportCrystalData2::cell];
		Return@cell
	];

	(* Correct ordering *)
	cell=Partition[cell,
	Length@cell/Quotient[Length@cell,6]];

	Do[
	X=cell[[i]];
	x=X[[All,1]];
	P=FindPermutation[x,{
	"_cell_length_a",
	"_cell_length_b",
	"_cell_length_c",
	"_cell_angle_alpha",
	"_cell_angle_beta",
	"_cell_angle_gamma"}];
	cell[[i]]=Permute[X,P],
	{i,Length@cell}];

	cell=cell[[All,All,2]];

(* B.3. Check subdata extraction *)
	(* Verify with fractional coordinates *)
	coordCount=StringCount[import,"_atom_site_fract_x"];
	If[coordCount===0,
	Message[ImportCrystalData2::atomData];Abort[]];	
	
	parts=Min[parts,coordCount];

	If[(multipleQ&&sub>parts)||(!multipleQ&&sub!=1),
	Message[ImportCrystalData2::subdataLength,parts];
	Abort[]];

	If[!IntegerQ[parts],
	Message[ImportCrystalData2::subdataInteger];
	Return@parts];

	(* Extract subdata *)
	cell=ToExpression@cell[[sub]];


(*---* C. Atom data *---*)
Label["AtomData"];

(* C.1. Extracting relevant data block *)
	(* Fractional coordinates *)
	(* Occupation factor *)
	(* Site symmetry multiplicity *)

	(* Extracting _atom_site loop *)
	atomdata=StringCases[import,Shortest[
labels:(Whitespace~~"_atom_site_"~~__~~"\n")~~data:(StartOfLine~~Whitespace...~~LetterCharacter~~__~~"\n")
~~{endstring,"_atom_site_aniso","_"~~Except["a"]}]:>{labels,data}];

		(* No data? *)
		If[atomdata=={},
		Message[ImportCrystalData2::atomData];
		Abort[]];

		(* Delete cases containing anisotropy data *)
		atomdata=DeleteCases[atomdata,
		x_/;StringContainsQ[x[[1]],"aniso"]];

	(* Specify sub-data *)
	atomdata=atomdata[[sub]];

(* C.2. Organising data *)
atomtags=Flatten@StringCases[atomdata[[1]],
"_atom_site_"~~{WordCharacter,"_"}..];

atomdata=StringDelete[atomdata[[2]],"("~~DigitCharacter..~~")"];
atomdata=Partition[StringSplit@atomdata,Length@atomtags];
atomdata=DeleteCases[atomdata,x_/;Length[x]!=Length[atomtags]];
atomdata=Association@Thread[atomtags->Transpose@atomdata];

(* C.3 Fixing entries *)
(* If 'site_type_symbol' is missing, copy 'site_label' *)
If[!KeyExistsQ[atomdata,"_atom_site_type_symbol"],
AppendTo[atomdata,
"_atom_site_type_symbol"->atomdata["_atom_site_label"]]];

(* Process and check elements *)
temp=atomdata["_atom_site_type_symbol"];
temp=InputCheck["InterpretElement",temp];

(* Optional: Clear any ion charges *)
If[OptionValue["IgnoreIonCharge"],
temp=StringDelete[temp,{"+","-",DigitCharacter}]];

(* Update 'atomdata' with 'temp' *)
atomdata["_atom_site_type_symbol"]=temp;


(*---* D. Anisotropic displacement parameters *---*)
(* D.1. If missing, use default values for ADP *)
L=Length@First@atomdata;
If[!KeyExistsQ[atomdata,"_atom_site_adp_type"],
AppendTo[atomdata,"_atom_site_adp_type"->ConstantArray["Uiso",L]]];
If[!KeyExistsQ[atomdata,"_atom_site_U_iso_or_equiv"],
AppendTo[atomdata,"_atom_site_U_iso_or_equiv"->ConstantArray[0,L]]];

(* D.2. Anisotropic displacement parameters *)
anisodata=StringCases[import,
Shortest["loop_"~~Whitespace~~
x:("_atom_site_aniso"~~__)~~endstring]:>x];

	(* Check *)
	If[anisodata==={},
	Goto["OrganiseAtomdata"],
	anisodata=anisodata[[sub]]];

(* D.3. Noting the order (permutation) *)
anisoOrder=Flatten@StringCases[anisodata,"U_"~~DigitCharacter..];
P=FindPermutation[{"U_11","U_22","U_33","U_12","U_13","U_23"},anisoOrder];

	(* Nothing there to extract? *)
	temp=Flatten@StringCases[anisodata,
	Shortest["_atom_site_aniso_"~~x__~~Whitespace]:>x];
	c=Flatten@Quiet@Position[temp,
	x_/;StringContainsQ[x,"U"]];

(* D.4. Extracting relevant data and trimming *)
anisodata=StringCases[anisodata,
Shortest["_atom_site_aniso"~~__~~EndOfLine]~~Whitespace~~(* Last line *)
x:(WordCharacter~~__):>x(* Content *)];

(* Check if there is any actual data *)
If[anisodata==={},Goto["OrganiseAtomdata"]];
anisodata=StringSplit[First@anisodata,Whitespace];
anisodata=StringReplace[anisodata,x__~~"("~~__~~")":>x];
anisodata=Partition[anisodata,Length@temp];

(* Correcting parameter order *)
anisodata[[All,c]]=Permute[#,P]&/@anisodata[[All,c]];

(* Associating each atom with values *)
anisodata=Association[
Table[anisodata[[i,1]]->anisodata[[i,c]],
{i,Length@anisodata}]];

(* D.5. Organising the atom data *)
Label["OrganiseAtomdata"];
atomoverview={};
tags={
"_atom_site_occupancy",
"_atom_site_site_symmetry_multiplicity",
"_atom_site_site_symmetry_order"};
labels={
"OccupationFactor",
"SiteSymmetryMultiplicity",
"SiteSymmetryOrder"};

Do[
item=<||>;
AppendTo[item,
"Element"->atomdata[["_atom_site_type_symbol",i]]];
Do[
If[KeyExistsQ[atomdata,tags[[j]]],
AppendTo[item,labels[[j]]->
atomdata[[tags[[j]],i]]]],
{j,Length@tags}];

AppendTo[item,"FractionalCoordinates"->
Evaluate[atomdata[["_atom_site_fract_"<>#,i]]&/@{"x","y","z"}]];
If[StringTake[
atomdata[["_atom_site_adp_type",i]],-3]==="ani",
disp=Part[anisodata,atomdata[["_atom_site_label",i]]],
disp=atomdata[["_atom_site_U_iso_or_equiv",i]]];

AppendTo[item,"DisplacementParameters"->disp];
AppendTo[item,"Type"->atomdata[["_atom_site_adp_type",i]]];
AppendTo[atomoverview,item],{i,Length@First@atomdata}];


(*---* E. Misc data labels *---*)
(* E.1. Wavelength *)
\[Lambda]=StringCases[import,Shortest["_diffrn_radiation_wavelength"~~
Whitespace~~x:{DigitCharacter,"."}..~~Whitespace]:>x];

If[\[Lambda]=={},\[Lambda]=-1,
If[Length@\[Lambda]>1,
\[Lambda]=ToExpression@\[Lambda][[sub]],
\[Lambda]=ToExpression@First@\[Lambda]]];

(* E.2. Forumla units (Z) *)
Z=StringCases[import,Shortest["_cell_formula_units_Z"~~
Whitespace~~z:DigitCharacter]:>z];

If[Z==={},Z=0,Z=ToExpression@First@Z];


(*---* F. Chemical formula *---*)
(* F.1. Extracting formula *)
formula=StringCases[import,
Shortest[#~~{Whitespace,"\n"}..~~{"'","\""}~~f__~~
{"'","\""}~~{Whitespace,"\n"}..]:>f]&/@{
(* Prioritised order *)
"_chemical_formula_iupac",
"_chemical_formula_structural",
"_chemical_formula_sum"};

formula=Select[Flatten@formula,!StringContainsQ[#,{",","?"}]&];
formula=StringDelete[formula,{"\r","~"}];

(* F.2. Check for simplest formula *)
temp=Select[formula,!StringContainsQ[#,"("]&];
If[temp=!={},formula={First@temp}];

(* F.3. Misc treatmeant and possible subdata selection *)
If[formula==={}||formula==={""},
chemicalformula="";Goto["SpaceGroup"]];

formula={StringDelete[StringTrim@First@formula,{"'","\""}]};

If[formula==={""},
chemicalformula="";Goto["SpaceGroup"],
formula=StringSplit@formula];

If[Length@formula>1,
formula=formula[[sub]],
formula=Flatten@formula];

(* F.4. Loop for formatting the chemical formula *)
Label["FormatFormula"];
If[AnyTrue[formula,StringContainsQ[#,{"(",")"}]&],
{l,r}=Flatten@Position[StringPosition[
formula,{"(",")"}],{{_,_}}];
	checkParentheses=True];

chemicalformula={};
Do[
temp=Flatten@StringCases[formula[[i]],
x:LetterCharacter..~~
y:({DigitCharacter,"."})..:>{x,y}];
Which[
temp=={},AppendTo[chemicalformula,formula[[i]]],
temp[[2]]=="1",AppendTo[chemicalformula,temp[[1]]],
True,AppendTo[chemicalformula,left<>temp[[1]]<>mid<>temp[[2]]<>right]],
{i,Length@formula}];

chemicalformula=StringDelete[chemicalformula,{"(",")"}];

(* Adding back parentheses *)
If[checkParentheses,
chemicalformula[[l]]="("<>chemicalformula[[l]];
chemicalformula[[r]]=chemicalformula[[r]]<>")"
];

chemicalformula=StringJoin@chemicalformula;


(*---* G. Space group *---*)
Label["SpaceGroup"];

(* G.1. Prioritised list of data labels *)
sgTags={
"_space_group_name_Hall",
"_space_group_name_H-M_alt",
"_space_group_IT_number",
"_symmetry_space_group_name_Hall",
"_symmetry_space_group_name_H-M",
"_symmetry_Int_Tables_number"};

(* G.2. Extract space group sections from imported data *)
sgData=StringCases[import,Shortest[sgTags~~__~~"loop_"]];
If[Length[sgData]>0,sgData=sgData[[sub]]];
sgData=StringTrim@StringDelete[sgData,"loop_"];

(* G.3. Make association of tags and corresponding info *)
sgData=StringCases[sgData,t:sgTags~~Whitespace~~sg:Shortest[Except[WhitespaceCharacter]~~__]~~{"\n",EndOfString}:>{t->sg}];
sgData=Association@Flatten@sgData;
sgData=DeleteCases[sgData,"?"];

(* G.4. Go through priority order and validate *)
Do[
sg=sgData[sgTags[[i]]];
sg=Quiet@InputCheck["InterpretSpaceGroup",sg,False];
If[sg=!=Null,Break[]],
{i,Length@sgTags}];

(* G.5. For modulated structures *)
If[sg===Null&&modulationQ,
sg=StringCases[import,
"_space_group_ssg_name"~~Whitespace~~
{"'","\""}~~sg__~~{"'","\""}~~"\n":>sg];
sg=StringCases[sg,Shortest[StartOfString~~___
~~sg:(LetterCharacter~~__)~~"("]:>sg];
If[sg=!={},sg=Quiet@InputCheck["InterpretSpaceGroup",
First@Flatten@sg,False]]
];

(* G.6. If missing space group, display message and use 'P1' *)
If[sg===Null,Message[ImportCrystalData2::SG];sg="P1"];


(*---* H. Adding item to dataset *---*)
options=Thread[#->OptionValue[#],String]&/@(
First/@Options@ImportCrystalData2);

ImportCrystalData2[
{name,chemicalformula,Z,sg,\[Lambda]},
cell,atomoverview,
options]
]


(* ::Input::Initialization:: *)
ExpandCrystal2::InvalidSize="The structure size must be a list of three natural numbers.";
ExpandCrystal2::DuplicateLabel="The new label must be different from the input.";

Options@ExpandCrystal2={
"DataFile"->FileNameJoin[{"CrystalData2.m"}],
"ExpandIntoNegative"->False,
"FirstTransformTo"->False,
"IgnoreSymmetry"->False,
"IncludeBoundary"->True,
"NewLabel"->"",
"StoreTemporarily"->False
};

SyntaxInformation@ExpandCrystal2={
"ArgumentsPattern"->{_,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
ExpandCrystal2[crystalData_,structureSize_List:{1,1,1},
OptionsPattern[]]:=Block[{crystalCopy=crystalData,
dataFile=OptionValue["DataFile"],
newLabel=OptionValue["NewLabel"],
changeCell=OptionValue["FirstTransformTo"],
storeTempQ=TrueQ@OptionValue["StoreTemporarily"],
ignoreSymmetryQ=TrueQ@OptionValue["IgnoreSymmetry"],
atomData,coordinates,spaceGroup,generated,
copyTranslations,mid,atomDataMapUnitCell,
cutoffFunction,atomDataMapExpanded,lengths,
newAtomData
},

(* Input check and data acquisition *)
If[
AllTrue[structureSize,Positive[#]&&IntegerQ[#]&]\[Nand]
Length[structureSize]===3,
Message[ExpandCrystal::InvalidSize];Abort[]];

(* Expand asymmetric unit to unit cell *)
atomData=crystalData["AtomData"];
coordinates=atomData[[All,"FractionalCoordinates"]];
spaceGroup=crystalData["SpaceGroup"];

(* Optional: Ignory symmetry and simply copy content as is *)
generated=N@If[ignoreSymmetryQ,
Partition[coordinates,1],
SymmetryEquivalentPositions[spaceGroup,#]&/@coordinates
];

(* Generate full content of the unit cell *)
atomDataMapUnitCell=Association@Thread[
Range@Length@atomData->generated];

(* Copy by translation *)
copyTranslations=InputCheck["GenerateTargetPositions",structureSize+1];
atomDataMapExpanded=Flatten[
Outer[Plus,copyTranslations,#,1],
1]&/@atomDataMapUnitCell;

(* Optional: Complete the outer boundary *)
cutoffFunction=If[TrueQ@OptionValue["IncludeBoundary"],
Greater,GreaterEqual];

(* Delete atoms whose coordinates are outside *)
atomDataMapExpanded=DeleteCases[atomDataMapExpanded,{x_,y_,z_}/;
Or@@MapThread[cutoffFunction,{{x,y,z},structureSize}],
{2}];

(* Optional: Center translations around origin *)
If[TrueQ@OptionValue["ExpandIntoNegative"],
mid=\[LeftFloor]structureSize/2.\[RightFloor];
atomDataMapExpanded=Map[#-mid&,atomDataMapExpanded,{2}];
];

(* Create new atom data structure *)
lengths=Values[Length/@atomDataMapExpanded];
newAtomData=Table[
ConstantArray[atomData[[i]],lengths[[i]]],
{i,Length@atomData}];

newAtomData[[All,All,"FractionalCoordinates"]]=
Values@atomDataMapExpanded;
newAtomData=Flatten[newAtomData,1];

(* Create new crystal entry *)
crystalCopy["AtomData"]=newAtomData;
AssociateTo[crystalCopy,"Notes"-><|
"StructureSize"->structureSize,
"UnitCellAtomsCount"->Total[Length/@generated],
"AsymmetricUnitAtomsCount"->Length@atomDataMapUnitCell
|>];

crystalCopy

]


(* ::Input::Initialization:: *)
SetupDensityHKL::odd="supercell expansion (n) should be odd";
SetupDensityHKL[mpid_String,n_Integer:1,hklMax_Integer:3,radiusFactor:(_Real|_Integer):1/3]:=Module[{crystalData,pg,latticeParameters,\[ScriptCapitalE],\[ScriptF]tmp,R,R1,R2,R3,\[ScriptCapitalO],\[ScriptCapitalE]Unique,covalentRadius,\[ScriptF],rKey,r,\[ScriptCapitalE]Pos,\[ScriptCapitalU],\[ScriptCapitalU]pts,reflectionList,hklList,\[ScriptCapitalP],\[ScriptCapitalR],rList,\[ScriptF]List,\[ScriptCapitalD],npts,\[ScriptCapitalA]Sym},

crystalData=ImportCrystalData2[mpid<>".cif",mpid,"OverwriteWarning"->False];
(*ExpandCrystal[mpid,{n,n,n},"NewLabel"\[Rule]mpid<>"_2","DataFile"\[Rule]mpid<>".m"];(*Defaults to 1x1x1*)*)
crystalData=ExpandCrystal2[crystalData,{n,n,n}];

(*CrystalData=Import[mpid<>".m"];*)
{\[ScriptCapitalE],\[ScriptF]tmp}=(Values/@crystalData[[(*mpid<>"_2",*)"AtomData",;;,{"Element","FractionalCoordinates"}]])\[Transpose];
pg=crystalData[[(*mpid,*)"SpaceGroup"]];
latticeParameters=Values@crystalData[[(*mpid,*)"LatticeParameters"]];
R=GetCrystalMetric[latticeParameters,ToCartesian->True];
(*R=GetCrystalMetric[mpid,ToCartesian\[Rule]True];*)
\[ScriptF]=\[ScriptF]tmp . R;
If[!OddQ@n,Message[SetupDensityHKL::odd]];
{R1,R2,R3}=R;
\[ScriptCapitalO]=Floor[n/2](R1+R2+R3);
\[ScriptF]=#-\[ScriptCapitalO]&/@\[ScriptF];
\[ScriptCapitalE]Unique=DeleteDuplicates@\[ScriptCapitalE];

covalentRadius=<|"H"->3.1`2.*^-11,"He"->2.8`2.*^-11,"Li"->1.28`3.*^-10,"Be"->9.6`2.*^-11,"B"->8.5`2.*^-11,"C"->7.6`2.*^-11,"N"->7.1`2.*^-11,"O"->6.6`2.*^-11,"F"->5.7`2.*^-11,"Ne"->5.8`2.*^-11,"Na"->1.66`3.*^-10,"Mg"->1.41`3.*^-10,"Al"->1.21`3.*^-10,"Si"->1.11`3.*^-10,"P"->1.07`3.*^-10,"S"->1.05`3.*^-10,"Cl"->1.02`3.*^-10,"Ar"->1.06`3.*^-10,"K"->2.03`3.*^-10,"Ca"->1.76`3.*^-10,"Sc"->1.7`3.*^-10,"Ti"->1.6`3.*^-10,"V"->1.53`3.*^-10,"Cr"->1.39`3.*^-10,"Mn"->1.39`3.*^-10,"Fe"->1.32`3.*^-10,"Co"->1.26`3.*^-10,"Ni"->1.24`3.*^-10,"Cu"->1.32`3.*^-10,"Zn"->1.22`3.*^-10,"Ga"->1.22`3.*^-10,"Ge"->1.2`3.*^-10,"As"->1.19`3.*^-10,"Se"->1.2`3.*^-10,"Br"->1.2`3.*^-10,"Kr"->1.16`3.*^-10,"Rb"->2.2`3.*^-10,"Sr"->1.95`3.*^-10,"Y"->1.9`3.*^-10,"Zr"->1.75`3.*^-10,"Nb"->1.64`3.*^-10,"Mo"->1.54`3.*^-10,"Tc"->1.47`3.*^-10,"Ru"->1.46`3.*^-10,"Rh"->1.42`3.*^-10,"Pd"->1.39`3.*^-10,"Ag"->1.45`3.*^-10,"Cd"->1.44`3.*^-10,"In"->1.42`3.*^-10,"Sn"->1.39`3.*^-10,"Sb"->1.39`3.*^-10,"Te"->1.38`3.*^-10,"I"->1.39`3.*^-10,"Xe"->1.4`3.*^-10,"Cs"->2.44`3.*^-10,"Ba"->2.15`3.*^-10,"La"->2.07`3.*^-10,"Ce"->2.04`3.*^-10,"Pr"->2.03`3.*^-10,"Nd"->2.01`3.*^-10,"Pm"->1.99`3.*^-10,"Sm"->1.98`3.*^-10,"Eu"->1.98`3.*^-10,"Gd"->1.96`3.*^-10,"Tb"->1.94`3.*^-10,"Dy"->1.92`3.*^-10,"Ho"->1.92`3.*^-10,"Er"->1.89`3.*^-10,"Tm"->1.9`3.*^-10,"Yb"->1.87`3.*^-10,"Lu"->1.87`3.*^-10,"Hf"->1.75`3.*^-10,"Ta"->1.7`3.*^-10,"W"->1.62`3.*^-10,"Re"->1.51`3.*^-10,"Os"->1.44`3.*^-10,"Ir"->1.41`3.*^-10,"Pt"->1.36`3.*^-10,"Au"->1.36`3.*^-10,"Hg"->1.32`3.*^-10,"Tl"->1.45`3.*^-10,"Pb"->1.46`3.*^-10,"Bi"->1.48`3.*^-10,"Po"->1.4`3.*^-10,"At"->1.5`3.*^-10,"Rn"->1.5`3.*^-10,"Fr"->2.6`3.*^-10,"Ra"->2.21`3.*^-10,"Ac"->2.15`3.*^-10,"Th"->2.06`3.*^-10,"Pa"->2.`3.*^-10,"U"->1.96`3.*^-10,"Np"->1.9`3.*^-10,"Pu"->1.87`3.*^-10,"Am"->1.8`3.*^-10,"Cm"->1.69`3.*^-10|>; (*produced via Association[ElementData[#,"Abbreviation"]\[Rule]QUC@ElementData[#,"CovalentRadius"]&/@Range@96]*)

rKey=covalentRadius[#]&/@\[ScriptCapitalE]Unique;
r=radiusFactor*ReplaceAll[\[ScriptCapitalE],Thread[\[ScriptCapitalE]Unique->rKey]]*1*^10(*conversion to Angstroms*);
\[ScriptCapitalE]Pos=PositionIndex@\[ScriptCapitalE];
\[ScriptCapitalU]=RationalUnitCell[R,n];

reflectionList=ReflectionList@hklMax;
hklList=MergeSymmetryEquivalentReflections[pg,reflectionList];
\[ScriptCapitalP]=MillerToPlane[#,R]&/@hklList;
\[ScriptCapitalR]=PlaneIntersection[\[ScriptCapitalP],\[ScriptCapitalU]];
\[ScriptF]List=\[ScriptF][[#/.\[ScriptCapitalE]Pos]]&/@\[ScriptCapitalE]Unique;
rList=r[[#/.\[ScriptCapitalE]Pos]]&/@\[ScriptCapitalE]Unique;

\[ScriptCapitalD]=MapThread[Rationalize@IsotropicMultinormal[#1,#2]&,{\[ScriptF]List,rList}];
npts=Length@Subscript[hkl, list2];
\[ScriptCapitalA]Sym=Area/@\[ScriptCapitalR]; (*/@\[ScriptCapitalR]*)
{\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP],\[ScriptCapitalA]Sym,\[ScriptF]List,rList,hklList,\[ScriptCapitalE]Unique,pg}
]


(* ::Input::Initialization:: *)
DistanceRadiusComparison[i_,j_,n_:3.99]:=Thread[#<n j]&/@i


(* ::Input::Initialization:: *)
TruePosition[x_]:=Flatten@Position[#,_?TrueQ]&/@x


(* ::Input::Initialization:: *)
AtomPolygonBallsIntersection[P_,c_,r_]:=Area/@MeshRegion/@DeleteCases[OpenCascadeShapeSurfaceMeshToBoundaryMesh/@OpenCascadeShape/@DeleteCases[(RegionIntersection[P,#]&/@MapThread[Ball[#1,#2]&,{c,r}]),_EmptyRegion],$Failed]


(* ::Input::Initialization:: *)
AtomPolygonBallsMap[P_,c_,r_]:=MapThread[If[#2!={},Flatten@AtomPolygonBallsIntersection[#1,#2,#3],0]&,{P,c,r}];


(* ::Input::Initialization:: *)
PolygonBallsIntersection[P_,c_,r_,n_:3.99]:=Module[{d,TF,ids,c2,r2,\[ScriptCapitalI]b,\[ScriptCapitalA]b},
d=Table[RegionDistance[i,j],{i,P},{j,#}]&/@c;
TF=MapThread[DistanceRadiusComparison[#1,#2,n]&,{d,r}];
ids=TruePosition[#]&/@TF;
c2=MapThread[#1/.Thread[Range@Length@#2->#2]&,{ids,c}];
r2=MapThread[#1/.Thread[Range@Length@#2->#2]&,{ids,r}];
(*{c2,r2}={c,r};*)
(*{c2,r2,P}*)
(*\[ScriptCapitalI]b=MapThread[Table[AtomPolygonBallsIntersection[i,#1,#2],{i,P}]&,{c2,r2}];*)
\[ScriptCapitalI]b=MapThread[AtomPolygonBallsMap[P,#1,#2]&,{c2,r2}];
(*\[ScriptCapitalI]b=Table[MapThread[If[#1\[LeftDoubleBracket]1\[RightDoubleBracket]\[NotEqual]{},Flatten@AtomPolygonBallsIntersection[{#2},#1\[LeftDoubleBracket]1\[RightDoubleBracket],#1\[LeftDoubleBracket]2\[RightDoubleBracket]],0]&,{i,P}],{i,{c2,r2}\[Transpose]}]*)
\[ScriptCapitalA]b=Total[#,{2}]&/@\[ScriptCapitalI]b
]


(* ::Input::Initialization:: *)
AtomProbabilityIntersection[\[ScriptCapitalD]_,P_]:=(*Parallel*)Table[Quiet[NIntegrate[PDF[i,{x,y,z}]/.PDF[0,{x,y,z}]->0(*for region distance filtering*),{x,y,z}\[Element]j,AccuracyGoal->10],{General::munfl,NIntegrate::slwcon,NIntegrate::precw}],{i,\[ScriptCapitalD]},{j,P}]


(* ::Input::Initialization:: *)
ProbabilityIntersection[\[ScriptCapitalD]_,\[ScriptCapitalR]_,\[ScriptCapitalP]_,n:(_Real|_Integer):3.99,radiusFactor:(_Real|_Integer):1/4]:=Module[{\[ScriptF]List,rList,distances,d,id,\[ScriptCapitalD]2,\[ScriptCapitalI]int,ids,\[ScriptCapitalA]int},
\[ScriptF]List=\[ScriptCapitalD][[;;,;;,1]];
rList=\[ScriptCapitalD][[;;,;;,2,1,1]][[;;,1]];(*assumes isotropic radius and assumes constant radius for a particular element*)
d=Table[RegionDistance[i,j],{i,\[ScriptCapitalP]},{j,#}]&/@\[ScriptF]List;
TF=MapThread[DistanceRadiusComparison[#1,#2,n]&,{d,rList}];
ids=TruePosition[#]&/@TF;
\[ScriptCapitalD]2=MapThread[#1/.Thread[Range@Length@#2->#2]&,{ids,\[ScriptCapitalD]}]/.{}->0;
\[ScriptCapitalI]int=Table[MapThread[Flatten@AtomProbabilityIntersection[#1,{#2}]&,{i,\[ScriptCapitalR]}],{i,\[ScriptCapitalD]2}];
ids=Position[\[ScriptCapitalI]int,Except[_Real|_Integer],{3},Heads->False];
ReplacePart[\[ScriptCapitalI]int,ids->0];
\[ScriptCapitalA]int=Total[#,{2}]&/@\[ScriptCapitalI]int;
\[ScriptCapitalA]int=\[ScriptCapitalA]int \[Pi] (1/radiusFactor rList)^2(*weight the probabilities by the area of the atoms*)
]


(* ::Input::Initialization:: *)
GetFullHKL[valsIn_,hklIn_,pg_]:=Module[{max,\[ScriptR],pi,reflectionList,hklList,valsReplace,n,npts,vals2,hklListSub,valsSub},
max=Max@hklIn;
\[ScriptR]=ReflectionList@max;
pi=PositionIndex[ToStandardSetting[pg,#]&/@\[ScriptR]];(*degenerate sets*)
hklList=MergeSymmetryEquivalentReflections[pg,\[ScriptR]];
valsReplace=Thread[Keys@PositionIndex[hklList]->valsIn]/.pi;
n=Length/@Keys@valsReplace;
npts=Length@\[ScriptR];
vals2=Range@npts/.(Thread[Keys@#->Values@#]&/@valsReplace//Flatten);
{\[ScriptR],vals2}
]


(* ::Input::Initialization:: *)
DensityHKL::mpidNotString="A string was expected for mpid.";
DensityHKL[mpid_:"mp-134",n_Integer:1,hklMax_Integer:3,dFactor:(_Real|_Integer):0.01,radiusFactorIn:(_Real|_Integer):0,OptionsPattern[{"Method"->"PDF","Output"->"PackingFraction","PrintID"->False,"PrintMethod"->False}]]:=Module[{method,radiusFactor,\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP],\[ScriptCapitalA]Sym,\[ScriptF]List,rList,hklList,\[ScriptCapitalE]Unique,\[ScriptCapitalA]out,\[ScriptCapitalA]outn,\[ScriptCapitalA]outCt,pg,hklFull,outCt,outn,\[ScriptCapitalA]fulln,\[ScriptCapitalA]fullCt},
(*If[Head@mpid=!=String,Message[DensityHKL::mpidNotString];Abort[]];*)
If[OptionValue["PrintID"],Print@mpid];
method=OptionValue["Method"];
If[OptionValue["PrintMethod"],Print@method];
If[radiusFactorIn==0,Switch[method,"PDF",radiusFactor=1/4,"HardSphere",radiusFactor=1],radiusFactor=radiusFactorIn];
{\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP],\[ScriptCapitalA]Sym,\[ScriptF]List,rList,hklList,\[ScriptCapitalE]Unique,pg}=SetupDensityHKL[mpid,n,hklMax,radiusFactor];
Switch[method,
"PDF",\[ScriptCapitalA]out=ProbabilityIntersection[\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP],dFactor],
"HardSphere",\[ScriptCapitalA]out=PolygonBallsIntersection[\[ScriptCapitalR],\[ScriptF]List,rList,dFactor]
];
\[ScriptCapitalA]outn=#/\[ScriptCapitalA]Sym&/@\[ScriptCapitalA]out;(*normalize by lattice plane area*)
\[ScriptCapitalA]outCt=MapThread[#1/(\[Pi] #2^2)&,{\[ScriptCapitalA]outn,rList[[;;,1]]}];
outn=GetFullHKL[#,hklList,pg]&/@\[ScriptCapitalA]outn;
hklFull=outn[[1,1]];(*extract a single hklListSub*)
\[ScriptCapitalA]fulln=outn[[;;,2]];(*extract just valsSub*)
outCt=GetFullHKL[#,hklList,pg]&/@\[ScriptCapitalA]outCt;
\[ScriptCapitalA]fullCt=outCt[[;;,2]];(*extract just valsSub*)
{\[ScriptCapitalA]outn,\[ScriptCapitalA]outCt,hklList,\[ScriptCapitalA]fulln,\[ScriptCapitalA]fullCt,hklFull,\[ScriptCapitalE]Unique}
]


(* ::Input::Initialization:: *)
PlotSetup[mpid_,n_:3,hklMax_:4]:=Module[{pg,reflectionList,hklList},
crystalData=ImportCrystalData2[mpid<>".cif",mpid,"OverwriteWarning"->False];
crystalData=ExpandCrystal2[crystalData,{n,n,n}];
pg=crystalData[["SpaceGroup"]];
reflectionList=ReflectionList@hklMax;
hklList=MergeSymmetryEquivalentReflections[pg,reflectionList];
{hklList,reflectionList,pg}
]


(* ::Code::Initialization::Bold:: *)
PlotSymmetrizedHKL[vals_,hkl_,o_Integer:1,legendLabel_:"\!\(\*FractionBox[SubscriptBox[\(\[ScriptCapitalA]\), \(\[Integral]\)], SubscriptBox[\(\[ScriptCapitalA]\), \(hkl\)]]\)(\!\(\*SuperscriptBox[\(\[CapitalARing]\), \(-2\)]\))"]:=Module[{max,c,g1},
max=Max@hkl;
c=ColorData[{"AvocadoColors",{0,Max@vals}}];
g1=Graphics3D[{Opacity[o],PointSize[0.05],Point[hkl,VertexColors->c/@vals]},Axes->True,BoxRatios->Automatic,AxesLabel->{"h","k","l"},PlotRange->ConstantArray[{0,max},3],ImageSize->Medium];
Show[Legended[g1,BarLegend[{c,c[[3]]},LegendLabel->legendLabel]],Graphics3D@{FaceForm[None],ConvexHullMesh@hkl}]
]


(* ::Code::Initialization::Bold:: *)
PlotFullHKL[valsIn_,hklIn_,pg_,o_Integer:0.75,legendLabel_:"\!\(\*FractionBox[SubscriptBox[\(\[ScriptCapitalA]\), \(\[Integral]\)], SubscriptBox[\(\[ScriptCapitalA]\), \(hkl\)]]\)(\!\(\*SuperscriptBox[\(\[CapitalARing]\), \(-2\)]\))"]:=Module[{c,max,hklFull,vals2,\[ScriptR],hklListSub,valsSub,g1},
c=ColorData[{"AvocadoColors",{0,Max@valsIn}}];
max=Max@hklIn;
{\[ScriptR],vals2}=GetFullHKL[valsIn,hklIn,pg];
{hklListSub,valsSub}=DeleteCases[{\[ScriptR],vals2}\[Transpose],{{x_,y_,z_},_}/;AllTrue[Thread[{x,y,z}>0],TrueQ]]\[Transpose];(*remove a corner of the cube for visualization*)
g1=Graphics3D[{Opacity[o],PointSize[0.08],Point[hklListSub,VertexColors->c/@valsSub]},Axes->True,BoxRatios->Automatic,AxesLabel->{"h","k","l"},ViewPoint->{max,0.6max,0.6max},AxesEdge->{{1,-1},{1,-1},{1,-1}}, PlotRange->ConstantArray[{-max,max},3],ImageSize->Medium];
Show[Legended[g1,BarLegend[{c,c[[3]]},LegendLabel->legendLabel]],Graphics3D@{EdgeForm[White],FaceForm[None],ConvexHullMesh@Permutations[{0,0,0,max,max,max},{3}](*ConvexHullMesh@Complement[hklList,hklListSub]*)}]
]


(* ::Input::Initialization:: *)
PlotSymmetrizedFullHKL[\[ScriptCapitalA]outNorm:_,hklList:_,pg_,\[ScriptCapitalE]Unique:_,tag_:"\[Integral]"]:=Module[{str,x},
str[x_]:=StringTemplate["\!\(\*FractionBox[SubscriptBox[\(\[ScriptCapitalA]\), \(`tag`, `element`\)], SubscriptBox[\(\[ScriptCapitalA]\), \(hkl\)]]\)(\!\(\*SuperscriptBox[\(\[CapitalARing]\), \(-2\)]\))"][<|"element"->x,"tag"->tag|>];
Grid[MapThread[{PlotSymmetrizedHKL[#1,hklList,str[#2]][[1]],PlotFullHKL[#1,hklList,pg,str[#2]]}&,
{\[ScriptCapitalA]outNorm,\[ScriptCapitalE]Unique}]]
]


(* ::Input::Initialization:: *)
End[];
Protect@@Names[Evaluate[Context[]<>"*"]];
Protect[Evaluate[Context[]<>"*"]];
EndPackage[];


(* ::Input::Initialization:: *)
(*Options[OneDimension]={"BasisVectors"\[Rule]Null};
OneDimension[\[ScriptCapitalI]_,\[Gamma]_,OptionsPattern[]]:=Module[{p,f,p1,f1,f2,f3,\[ScriptCapitalO],\[ScriptCapitalA],\[ScriptCapitalB],B},
B=OptionValue["BasisVectors"];
opts="BasisVectors"\[Rule]B;
{p,f}=GetPositions@\[ScriptCapitalI];
p1=p\[LeftDoubleBracket]1\[RightDoubleBracket];
{f1,f2}=f;
f3=Complement[Range[3],f];
If[B===Null,
\[ScriptCapitalO]=AssignAxis[p1,\[ScriptCapitalI],\[Gamma]],
\[ScriptCapitalO]=(B\[LeftDoubleBracket]f3\[RightDoubleBracket]\[ScriptCapitalI]\[LeftDoubleBracket]f3\[RightDoubleBracket])\[LeftDoubleBracket]1\[RightDoubleBracket]
];
\[ScriptCapitalA]=AssignAxis[f1,1,\[Gamma],opts];
\[ScriptCapitalB]=AssignAxis[f2,1,\[Gamma],opts];
InfinitePlane[\[ScriptCapitalO],{\[ScriptCapitalA],\[ScriptCapitalB]}]
]*)


(* ::Input::Initialization:: *)
(*TwoDimension[\[ScriptCapitalI]_,\[Gamma]_,OptionsPattern[{"BasisVectors"\[Rule]Null}]]:=Module[{p,f,p1,p2,f1,f2,f3,B,opts,negQ,\[ScriptCapitalO],\[ScriptCapitalA],\[ScriptCapitalB],v1,v2,pt,out},
{p,f}=GetPositions@\[ScriptCapitalI];
{p1,p2}=p\[LeftDoubleBracket] ;;2\[RightDoubleBracket];
f1=f\[LeftDoubleBracket]1\[RightDoubleBracket];
{f2,f3}=Complement[Range@3,f];
B=OptionValue["BasisVectors"];
opts="BasisVectors"\[Rule]B;
If[B===Null,

\[ScriptCapitalO]=AssignAxis[p1,\[ScriptCapitalI],\[Gamma]];
\[ScriptCapitalA]=AssignAxis[p2,\[ScriptCapitalI],\[Gamma]],

\[ScriptCapitalO]=B\[LeftDoubleBracket]f2\[RightDoubleBracket]\[ScriptCapitalI]\[LeftDoubleBracket]f2\[RightDoubleBracket];
\[ScriptCapitalA]=B\[LeftDoubleBracket]f3\[RightDoubleBracket]\[ScriptCapitalI]\[LeftDoubleBracket]f3\[RightDoubleBracket];
];
\[ScriptCapitalB]=AssignAxis[f1,1,\[Gamma],opts];
Print@{f1,f2,f3};
Print[\[ScriptCapitalI]\[LeftDoubleBracket]{f2,f3}\[RightDoubleBracket]];
Print@{\[ScriptCapitalI],B};
(*Print@{\[ScriptCapitalA],\[ScriptCapitalA]-\[ScriptCapitalO],\[ScriptCapitalB],\[ScriptCapitalO],{0,0,0}};*)
(*negQ=Negative@B;*)
(*If[Negative[\[ScriptCapitalI]\[LeftDoubleBracket]f2\[RightDoubleBracket]],\[ScriptCapitalO]=\[ScriptCapitalO]+B\[LeftDoubleBracket]f2\[RightDoubleBracket];Print@"Neg1"];
If[Negative[\[ScriptCapitalI]\[LeftDoubleBracket]f3\[RightDoubleBracket]],\[ScriptCapitalA]=\[ScriptCapitalA]+B\[LeftDoubleBracket]f3\[RightDoubleBracket];Print@"Neg2"];*)
(*pt=\[ScriptCapitalA];
v1=\[ScriptCapitalA]-\[ScriptCapitalO];
v2=\[ScriptCapitalB];*)
out=If[B===Null,
InfinitePlane[{0,0,0},{\[ScriptCapitalA]-\[ScriptCapitalO],\[ScriptCapitalB]}],
(*InfinitePlane[pt,{v1,v2}]*)
Print[Positive@\[ScriptCapitalI]\[LeftDoubleBracket]{f2,f3}\[RightDoubleBracket]];
Switch[Positive@\[ScriptCapitalI]\[LeftDoubleBracket]{f2,f3}\[RightDoubleBracket],
{False,True},InfinitePlane[\[ScriptCapitalA]+\[ScriptCapitalO],{\[ScriptCapitalA]+\[ScriptCapitalO],\[ScriptCapitalB]}],
{False,False},InfinitePlane[\[ScriptCapitalA]-\[ScriptCapitalO]-\[ScriptCapitalB],{\[ScriptCapitalA]-\[ScriptCapitalO],\[ScriptCapitalB]}],
{True,False},InfinitePlane[\[ScriptCapitalA]-\[ScriptCapitalB],{\[ScriptCapitalA]-\[ScriptCapitalO],\[ScriptCapitalB]}],
{True,True},InfinitePlane[\[ScriptCapitalA],{\[ScriptCapitalA]-\[ScriptCapitalO],\[ScriptCapitalB]}]
]
];
out
]*)


(* ::Input::Initialization:: *)
(*AssignAxis::badArgs="If B is Null, then \[Gamma] should not be Null and vice-versa";
AssignAxis[n_,valIn_,\[Gamma]_,OptionsPattern[{"BasisVectors"\[Rule]Null}]]:=Module[{val,B,out},
val=If[Length@valIn\[Equal]0,valIn,valIn\[LeftDoubleBracket]n\[RightDoubleBracket]];
B=OptionValue["BasisVectors"];
(*tri=SASTriangle[a,\[Gamma],b]\[LeftDoubleBracket]1\[RightDoubleBracket];*)
If[(B===Null)&&(\[Gamma]===Null),Message[AssignAxis::badArgs]];
out=If[B===Null,
Switch[n,1,{val,0,0},2,{val,val,0}*{Cos[(*90\[Degree]-*)\[Gamma]],Sin[(*90\[Degree]-*)\[Gamma]],0},3,{0,0,val}],
B\[LeftDoubleBracket]n\[RightDoubleBracket]Abs@val
];
Rationalize[out,0]
]*)


(* ::Input::Initialization:: *)
(*AssignAxes[\[ScriptCapitalI]_,\[Gamma]_,OptionsPattern[{"BasisVectors"\[Rule]Null}]]:=Module[{},
AssignAxis[#1,\[ScriptCapitalI],\[Gamma],"BasisVectors"\[Rule]OptionValue["BasisVectors"]]&/@{1,2,3}
]*)


(* ::Input::Initialization:: *)
(*GetPositions[\[ScriptCapitalI]_]:=Flatten@Position[NumberQ/@\[ScriptCapitalI],#]&/@{True(*p*),False(*f*)}*)


(* ::Input::Initialization:: *)
(*Options[MillerToPlane]={"BasisVectors"\[Rule]Null,"\[Gamma]"\[Rule]Null};
MillerToPlane[hkl_,\[Gamma]_:Null,OptionsPattern[]]:=Module[{\[ScriptCapitalI],p1,p,f,B,negQ,\[Gamma]1,out},
If[\[Gamma]===Null,\[Gamma]1=OptionValue["\[Gamma]"],\[Gamma]1=\[Gamma]];
\[ScriptCapitalI]=Reciprocal[hkl];
B=OptionValue["BasisVectors"];
If[B=!=Null,
B=Rationalize[B,0];
negQ=Negative[\[ScriptCapitalI]/.Indeterminate\[Rule]0];(*which ones are negative?*)
B=MapThread[If[#1,-#2,#2]&,{negQ,B}](*if negative, flip the corresponding basis vector element*) 
];
{p,f}=GetPositions@\[ScriptCapitalI];
out=Switch[Length@p(*number of real-valued dimensions*),1,OneDimension[\[ScriptCapitalI],\[Gamma]1,"BasisVectors"\[Rule]B],2,TwoDimension[\[ScriptCapitalI],\[Gamma]1,"BasisVectors"\[Rule]B],3,InfinitePlane@AssignAxes[\[ScriptCapitalI],\[Gamma]1,"BasisVectors"\[Rule]B]];
out
]*)
